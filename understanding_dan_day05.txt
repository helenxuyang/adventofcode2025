// https://github.com/danzou56/advent-of-code/blob/master/src/main/kotlin/dev/danzou/advent25/Day5.kt
  
  example:
    3-5
    10-14
    16-20
    12-18

    ids: 3,4,5,10,11,12,13,14,15,16,17,18,19,20


  override fun part2(input: String): Long =
      parseIngredients(input)
          .first
          .fold(listOf<LongRange>()) { ranges, el -> merge(ranges, el) }
          .sumOf { it.last - it.first + 1 }


  fun parseIngredients(input: String): Pair<List<LongRange>, List<Long>> {
    val (rangeLines, availableLines) = input.split("\n\n")
    return rangeLines
        .lines()
        .map { line -> line.split("-").map(String::toLong) } // parse 3-5 to numbers 3 and 5
        .map { (f, s) -> f..s } to availableLines.lines().map(String::toLong) // 3 and 5 to range 3..5
        // "to" is syntax for a pair so this returns a pair with parsed ranges and parsed ids (from part 1)
  }

  
  parseIngredients(input).first just gets the first of the pair
  
  [3..5, 10..14, 16..20, 12..18]
      
  .fold(listOf<LongRange>()) { ranges, el -> merge(ranges, el) } // the empty list in () is the initial value, then merge will get called on the list of ranges
  .sumOf { it.last - it.first + 1 }

  tailrec fun merge(ranges: List<LongRange>, newRange: LongRange): List<LongRange> {
      val index =
        ranges.binarySearch {
          when {
            it.intersects(newRange) -> 0
            it.last < newRange.first -> -1
            else -> 1
          }
        }
    return if (index < 0) {
      val insertionIndex = -index - 1
      ranges.take(insertionIndex) + listOf(newRange) + ranges.drop(insertionIndex)
    } else {
      val target = ranges[index]
      val unioned = min(target.first, newRange.first)..max(target.last, newRange.last)
      merge(ranges.take(index) + ranges.drop(index + 1), unioned)
    }
  }

  start with ranges=[], newRange=3..5
  binary search - index 0, out of bounds so returns (-0-1)=-1
  if branch - insertionIndex = 0 so ranges is now [3..5]

  recursive call with ranges=[3..5], newRange=10..14
  binary search - index 1, out of bounds so returns (-1-1)=-2
  if branch - insertionIndex = 1 so ranges is now [3..5, 10..14]

  recursive call with ranges=[3..5, 10..14], newRange=16..20
  binary search - index 2, out of bounds so returns (-2-1)=-3
  if branch - insertionIndex = 2 so ranges is now [3..5, 10..14, 16..20]

  recursive call with ranges=[3..5, 10..14, 16..20], newRange=12..18
  binary search - intersects with 10..14 so returns 1
  else branch - target is 10..14, unioned is min(10,12)..max(14,18) = 10..18
  
  recursive call with ranges=[3..5, 16..20], newRange=10..18
  binary search - intersects with 16..20 so returns 1
  else branch - target is 16..20, unioned is min(16,10)..max(20,18) = 10..20

  recursive call with ranges=[3..5], newRange = 10..20
  binary search - index 1, out of bounds so returns (-1-1)=-2
  if branch - insertionIndex = 1 so ranges is now [3..5, 10..20]








